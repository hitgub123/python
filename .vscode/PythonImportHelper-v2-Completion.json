[
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "preprocessing",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "fetch_openml",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "fetch_openml",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "def train():\n    for i in range(epochs):\n        batch_loss = []\n        for start in range(0, data_size, batch_size):\n            optimizer.zero_grad()\n            end = start + batch_size if start + batch_size < data_size else data_size \n            x, y = X_train[start:end], y_train[start:end]\n            prediction = model(x)\n            loss = cost(prediction, y)\n            loss.backward()",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "def test():\n    model.load_state_dict(tc.load(model_name, weights_only=0))\n    prediction = model(X_test).argmax(axis=1)\n    acc_rate = (prediction == y_test).sum() / y_test.size()[0]\n    print(acc_rate.item())\n    # print(model)\n    # for i,j in enumerate(model.named_parameters()):\n    #     print(i,j)\nif __name__ == \"__main__\":\n    train()",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "mnist",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "mnist = fetch_openml(\"mnist_784\", version=1, cache=True)\nmnist.target = mnist.target.astype(np.int8)\nX, y = mnist[\"data\"], mnist[\"target\"]\nX[:60000].to_numpy()\nX_train, X_test, y_train, y_test = map(\n    lambda df: df.to_numpy(), (X[:60000], X[60000:], y[:60000], y[60000:])\n)\n# 洗牌训练集\nshuffle_index = np.random.permutation(60000)\nX_train, y_train = X_train[shuffle_index], y_train[shuffle_index]",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "mnist.target",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "mnist.target = mnist.target.astype(np.int8)\nX, y = mnist[\"data\"], mnist[\"target\"]\nX[:60000].to_numpy()\nX_train, X_test, y_train, y_test = map(\n    lambda df: df.to_numpy(), (X[:60000], X[60000:], y[:60000], y[60000:])\n)\n# 洗牌训练集\nshuffle_index = np.random.permutation(60000)\nX_train, y_train = X_train[shuffle_index], y_train[shuffle_index]\nX_train = preprocessing.StandardScaler().fit_transform(X_train)",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "shuffle_index",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "shuffle_index = np.random.permutation(60000)\nX_train, y_train = X_train[shuffle_index], y_train[shuffle_index]\nX_train = preprocessing.StandardScaler().fit_transform(X_train)\nX_test = preprocessing.StandardScaler().fit_transform(X_test)\n# y_train = pd.get_dummies(y_train)\n# y_test = pd.get_dummies(y_test)\nX_train, y_train, X_test, y_test = map(tc.tensor, (X_train, y_train, X_test, y_test))\nX_train, X_test = X_train.to(tc.float64), X_test.to(tc.float64)\ny_train, y_test = y_train.to(tc.long), y_test.to(tc.long)\ny_train = tc.nn.functional.one_hot(y_train, num_classes=10)",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "X_train",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "X_train = preprocessing.StandardScaler().fit_transform(X_train)\nX_test = preprocessing.StandardScaler().fit_transform(X_test)\n# y_train = pd.get_dummies(y_train)\n# y_test = pd.get_dummies(y_test)\nX_train, y_train, X_test, y_test = map(tc.tensor, (X_train, y_train, X_test, y_test))\nX_train, X_test = X_train.to(tc.float64), X_test.to(tc.float64)\ny_train, y_test = y_train.to(tc.long), y_test.to(tc.long)\ny_train = tc.nn.functional.one_hot(y_train, num_classes=10)\ny_train = y_train.to(tc.float64)\n#####################################################",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "X_test",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "X_test = preprocessing.StandardScaler().fit_transform(X_test)\n# y_train = pd.get_dummies(y_train)\n# y_test = pd.get_dummies(y_test)\nX_train, y_train, X_test, y_test = map(tc.tensor, (X_train, y_train, X_test, y_test))\nX_train, X_test = X_train.to(tc.float64), X_test.to(tc.float64)\ny_train, y_test = y_train.to(tc.long), y_test.to(tc.long)\ny_train = tc.nn.functional.one_hot(y_train, num_classes=10)\ny_train = y_train.to(tc.float64)\n#####################################################\n#################### model ##########################",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "y_train",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "y_train = tc.nn.functional.one_hot(y_train, num_classes=10)\ny_train = y_train.to(tc.float64)\n#####################################################\n#################### model ##########################\n#####################################################\nhidden_size1 = 128\nhidden_size2 = 70\ndata_size = X_train.shape[0]\ninput_size = X_train.shape[-1]\noutput_size = 10",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "y_train",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "y_train = y_train.to(tc.float64)\n#####################################################\n#################### model ##########################\n#####################################################\nhidden_size1 = 128\nhidden_size2 = 70\ndata_size = X_train.shape[0]\ninput_size = X_train.shape[-1]\noutput_size = 10\nbatch_size = 128",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "hidden_size1",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "hidden_size1 = 128\nhidden_size2 = 70\ndata_size = X_train.shape[0]\ninput_size = X_train.shape[-1]\noutput_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 200\nmodel_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "hidden_size2",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "hidden_size2 = 70\ndata_size = X_train.shape[0]\ninput_size = X_train.shape[-1]\noutput_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 200\nmodel_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "data_size",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "data_size = X_train.shape[0]\ninput_size = X_train.shape[-1]\noutput_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 200\nmodel_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),\n    tc.nn.ReLU(),",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "input_size",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "input_size = X_train.shape[-1]\noutput_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 200\nmodel_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),\n    tc.nn.ReLU(),\n    tc.nn.Linear(hidden_size1, hidden_size2, dtype=float),",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "output_size",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "output_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 200\nmodel_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),\n    tc.nn.ReLU(),\n    tc.nn.Linear(hidden_size1, hidden_size2, dtype=float),\n    tc.nn.ReLU(),",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "batch_size",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "batch_size = 128\nlr = 0.001\nepochs = 200\nmodel_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),\n    tc.nn.ReLU(),\n    tc.nn.Linear(hidden_size1, hidden_size2, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "lr",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "lr = 0.001\nepochs = 200\nmodel_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),\n    tc.nn.ReLU(),\n    tc.nn.Linear(hidden_size1, hidden_size2, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size2, output_size, dtype=float),",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "epochs",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "epochs = 200\nmodel_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),\n    tc.nn.ReLU(),\n    tc.nn.Linear(hidden_size1, hidden_size2, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size2, output_size, dtype=float),\n)",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "model_name",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "model_name = \"pytorch/learn1/models/mnist.pkl\"\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),\n    tc.nn.ReLU(),\n    tc.nn.Linear(hidden_size1, hidden_size2, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size2, output_size, dtype=float),\n)\ncost = tc.nn.CrossEntropyLoss()",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "model = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size1, dtype=float),\n    tc.nn.ReLU(),\n    tc.nn.Linear(hidden_size1, hidden_size2, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size2, output_size, dtype=float),\n)\ncost = tc.nn.CrossEntropyLoss()\noptimizer = tc.optim.Adam(model.parameters(), lr=lr)",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "cost",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "cost = tc.nn.CrossEntropyLoss()\noptimizer = tc.optim.Adam(model.parameters(), lr=lr)\ndef train():\n    for i in range(epochs):\n        batch_loss = []\n        for start in range(0, data_size, batch_size):\n            optimizer.zero_grad()\n            end = start + batch_size if start + batch_size < data_size else data_size \n            x, y = X_train[start:end], y_train[start:end]\n            prediction = model(x)",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "optimizer",
        "kind": 5,
        "importPath": "pytorch.learn1.002_mnist预测",
        "description": "pytorch.learn1.002_mnist预测",
        "peekOfCode": "optimizer = tc.optim.Adam(model.parameters(), lr=lr)\ndef train():\n    for i in range(epochs):\n        batch_loss = []\n        for start in range(0, data_size, batch_size):\n            optimizer.zero_grad()\n            end = start + batch_size if start + batch_size < data_size else data_size \n            x, y = X_train[start:end], y_train[start:end]\n            prediction = model(x)\n            loss = cost(prediction, y)",
        "detail": "pytorch.learn1.002_mnist预测",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "path = \"pytorch/learn1/models/\"\nmodel_name = path+\"mnist.pkl\"\n#####################################################\n#################### data ##########################\n#####################################################\nmnist = fetch_openml(\"mnist_784\", version=1, cache=True)\nmnist.target = mnist.target.astype(np.int8)\nX, y = mnist[\"data\"], mnist[\"target\"]\nX_train, X_test, y_train, y_test = map(\n    lambda df: df.to_numpy(), (X[:60000], X[60000:], y[:60000], y[60000:])",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "model_name",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "model_name = path+\"mnist.pkl\"\n#####################################################\n#################### data ##########################\n#####################################################\nmnist = fetch_openml(\"mnist_784\", version=1, cache=True)\nmnist.target = mnist.target.astype(np.int8)\nX, y = mnist[\"data\"], mnist[\"target\"]\nX_train, X_test, y_train, y_test = map(\n    lambda df: df.to_numpy(), (X[:60000], X[60000:], y[:60000], y[60000:])\n)",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "mnist",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "mnist = fetch_openml(\"mnist_784\", version=1, cache=True)\nmnist.target = mnist.target.astype(np.int8)\nX, y = mnist[\"data\"], mnist[\"target\"]\nX_train, X_test, y_train, y_test = map(\n    lambda df: df.to_numpy(), (X[:60000], X[60000:], y[:60000], y[60000:])\n)\nX_test = preprocessing.StandardScaler().fit_transform(X_test)\nX_test, y_test = map(tc.tensor, (X_test, y_test))\nX_test = X_test.to(tc.float64)\ny_test = y_test.to(tc.long)",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "mnist.target",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "mnist.target = mnist.target.astype(np.int8)\nX, y = mnist[\"data\"], mnist[\"target\"]\nX_train, X_test, y_train, y_test = map(\n    lambda df: df.to_numpy(), (X[:60000], X[60000:], y[:60000], y[60000:])\n)\nX_test = preprocessing.StandardScaler().fit_transform(X_test)\nX_test, y_test = map(tc.tensor, (X_test, y_test))\nX_test = X_test.to(tc.float64)\ny_test = y_test.to(tc.long)\n#####################################################",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "X_test",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "X_test = preprocessing.StandardScaler().fit_transform(X_test)\nX_test, y_test = map(tc.tensor, (X_test, y_test))\nX_test = X_test.to(tc.float64)\ny_test = y_test.to(tc.long)\n#####################################################\n#################### model ##########################\n#####################################################\nhidden_size = 128\ndata_size = 60000\ninput_size = 784",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "X_test",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "X_test = X_test.to(tc.float64)\ny_test = y_test.to(tc.long)\n#####################################################\n#################### model ##########################\n#####################################################\nhidden_size = 128\ndata_size = 60000\ninput_size = 784\noutput_size = 10\nbatch_size = 128",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "y_test",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "y_test = y_test.to(tc.long)\n#####################################################\n#################### model ##########################\n#####################################################\nhidden_size = 128\ndata_size = 60000\ninput_size = 784\noutput_size = 10\nbatch_size = 128\nlr = 0.001",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "hidden_size",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "hidden_size = 128\ndata_size = 60000\ninput_size = 784\noutput_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 100\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size, dtype=float),\n    tc.nn.ReLU(),",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "data_size",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "data_size = 60000\ninput_size = 784\noutput_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 100\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "input_size",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "input_size = 784\noutput_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 100\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size, output_size, dtype=float),",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "output_size",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "output_size = 10\nbatch_size = 128\nlr = 0.001\nepochs = 100\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size, output_size, dtype=float),\n)",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "batch_size",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "batch_size = 128\nlr = 0.001\nepochs = 100\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size, output_size, dtype=float),\n)\nmodel.load_state_dict(tc.load(model_name, weights_only=0))",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "lr",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "lr = 0.001\nepochs = 100\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size, output_size, dtype=float),\n)\nmodel.load_state_dict(tc.load(model_name, weights_only=0))\nprediction = model(X_test).argmax(axis=1)",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "epochs",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "epochs = 100\nmodel = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size, output_size, dtype=float),\n)\nmodel.load_state_dict(tc.load(model_name, weights_only=0))\nprediction = model(X_test).argmax(axis=1)\nacc_rate = (prediction == y_test).sum() / y_test.size()[0]",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "model = tc.nn.Sequential(\n    tc.nn.Linear(input_size, hidden_size, dtype=float),\n    tc.nn.ReLU(),\n    # tc.nn.Sigmoid(),\n    tc.nn.Linear(hidden_size, output_size, dtype=float),\n)\nmodel.load_state_dict(tc.load(model_name, weights_only=0))\nprediction = model(X_test).argmax(axis=1)\nacc_rate = (prediction == y_test).sum() / y_test.size()[0]\nprint(acc_rate.item())",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "prediction",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "prediction = model(X_test).argmax(axis=1)\nacc_rate = (prediction == y_test).sum() / y_test.size()[0]\nprint(acc_rate.item())",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    },
    {
        "label": "acc_rate",
        "kind": 5,
        "importPath": "pytorch.learn1.test_model",
        "description": "pytorch.learn1.test_model",
        "peekOfCode": "acc_rate = (prediction == y_test).sum() / y_test.size()[0]\nprint(acc_rate.item())",
        "detail": "pytorch.learn1.test_model",
        "documentation": {}
    }
]